{"version":3,"file":"createServerFn.js","sources":["../../src/createServerFn.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\n\nexport const serverFnReturnTypeHeader = 'server-fn-return-type'\nexport const serverFnPayloadTypeHeader = 'server-fn-payload-type'\n\nexport interface JsonResponse<TData> extends Response {\n  json(): Promise<TData>\n}\n\nexport type FetcherOptionsBase = {\n  method?: 'GET' | 'POST'\n}\n\nexport type FetcherOptions = FetcherOptionsBase & {\n  requestInit?: RequestInit\n}\n\nexport type FetchFnCtx = {\n  method: 'GET' | 'POST'\n  request: Request\n}\n\nexport type FetchFn<TPayload, TResponse> = {\n  (payload: TPayload, ctx: FetchFnCtx): Promise<TResponse> | TResponse\n  url?: string\n}\n\nexport type CompiledFetcherFnOptions<TPayload> = {\n  method: 'GET' | 'POST'\n  payload: TPayload | undefined\n  requestInit?: RequestInit\n}\n\nexport type CompiledFetcherFn<TPayload, TResponse> = {\n  (opts: CompiledFetcherFnOptions<TPayload>): Promise<TResponse>\n  url: string\n}\n\ntype IsPayloadOptional<T> = [T] extends [undefined] ? true : false\n\nexport type Fetcher<TPayload, TResponse> =\n  (IsPayloadOptional<TPayload> extends true\n    ? {\n        (\n          payload?: TPayload,\n          opts?: FetcherOptions,\n        ): Promise<JsonResponseOrPayload<TResponse>>\n      }\n    : {\n        (\n          payload: TPayload,\n          opts?: FetcherOptions,\n        ): Promise<JsonResponseOrPayload<TResponse>>\n      }) & {\n    url: string\n  }\n\nexport type JsonResponseOrPayload<TResponse> =\n  TResponse extends JsonResponse<infer TData> ? TData : TResponse\n\nexport function createServerFn<\n  TPayload extends any = undefined,\n  TResponse = unknown,\n>(\n  method: 'GET' | 'POST',\n  fn: FetchFn<TPayload, TResponse>,\n): Fetcher<TPayload, TResponse> {\n  // Cast the compiled function that will be injected by vinxi\n  const compiledFn = fn as unknown as CompiledFetcherFn<TPayload, TResponse>\n\n  invariant(\n    compiledFn.url,\n    `createServerFn must be called with a function that is marked with the 'use server' pragma.`,\n  )\n\n  return Object.assign(\n    async (payload: TPayload, opts?: FetcherOptions) => {\n      return compiledFn({\n        method,\n        payload: payload || undefined,\n        requestInit: opts?.requestInit,\n      })\n    },\n    {\n      url: fn.url!,\n    },\n  ) as Fetcher<TPayload, TResponse>\n}\n\nexport function json<TData>(\n  payload: TData,\n  opts?: {\n    status?: number\n    statusText?: string\n    headers?: HeadersInit\n  },\n): JsonResponse<TData> {\n  return new Response(JSON.stringify(payload), {\n    status: opts?.status || 200,\n    statusText: opts?.statusText || opts?.status === 200 ? 'OK' : 'Error',\n    headers: {\n      'Content-Type': 'application/json',\n      [serverFnReturnTypeHeader]: 'json',\n      ...opts?.headers,\n    },\n  })\n}\n"],"names":[],"mappings":";AAEO,MAAM,2BAA2B;AACjC,MAAM,4BAA4B;AAyDzB,SAAA,eAId,QACA,IAC8B;AAE9B,QAAM,aAAa;AAEnB;AAAA,IACE,WAAW;AAAA,IACX;AAAA,EAAA;AAGF,SAAO,OAAO;AAAA,IACZ,OAAO,SAAmB,SAA0B;AAClD,aAAO,WAAW;AAAA,QAChB;AAAA,QACA,SAAS,WAAW;AAAA,QACpB,aAAa,6BAAM;AAAA,MAAA,CACpB;AAAA,IACH;AAAA,IACA;AAAA,MACE,KAAK,GAAG;AAAA,IACV;AAAA,EAAA;AAEJ;AAEgB,SAAA,KACd,SACA,MAKqB;AACrB,SAAO,IAAI,SAAS,KAAK,UAAU,OAAO,GAAG;AAAA,IAC3C,SAAQ,6BAAM,WAAU;AAAA,IACxB,aAAY,6BAAM,gBAAc,6BAAM,YAAW,MAAM,OAAO;AAAA,IAC9D,SAAS;AAAA,MACP,gBAAgB;AAAA,MAChB,CAAC,wBAAwB,GAAG;AAAA,MAC5B,GAAG,6BAAM;AAAA,IACX;AAAA,EAAA,CACD;AACH;"}